<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>couch</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="icon" href="/images/icon.png" />

<style>
@font-face {
  font-family: "RuneScape UF";
  src: url("../../fonts/RuneScape-UF.woff2") format("woff2"),
       url("../../fonts/RuneScape-UF.woff") format("woff");
}

html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  background: white;
  font-family: "RuneScape UF", Arial, sans-serif;

  -webkit-user-select: none;
  -webkit-touch-callout: none;
  -webkit-tap-highlight-color: transparent;
  user-select: none;

  cursor: url("../../images/cursor/cursor.png"), auto;
}

/* STOP MOBILE LONG-PRESS CALLOUTS / BLACK BOX */
body, .stage, .stage * {
  -webkit-user-select: none;
  user-select: none;
  -webkit-touch-callout: none;
  -webkit-user-drag: none;
  touch-action: none;
}

.back-button {
  position: fixed;
  top: 8px;
  left: 8px;
  font-size: 28px;
  background: transparent;
  border: none;
  color: #2d93ea;
  font-family: "RuneScape UF", Arial, sans-serif;
  cursor: url("../../images/cursor/cursor-hover.png"), pointer;
  text-transform: lowercase;
  padding: 0;
  z-index: 10;
}

.wrapper {
  height: 100%;
  width: 100%;
  display: grid;
  place-items: center;
}

.stack {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 16px;
}

.stage {
  position: relative;
  width: min(70vw, 360px);
  aspect-ratio: 1 / 1;
}

.stage img {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: contain;

  image-rendering: pixelated;
  image-rendering: crisp-edges;
}

.couch { z-index: 1; }

.fire {
  z-index: 2;
  opacity: 0;
  transition: opacity 80ms;
  will-change: transform;
}

.smoke {
  z-index: 3;
  opacity: 0;
  transition: opacity 140ms;
  will-change: transform;
}

.status {
  font-size: 22px;
  color: #2d93ea;
  text-transform: lowercase;
  line-height: 1;
}
</style>
</head>

<body>
<button class="back-button" onclick="goBack()">‚Üê back</button>

<div class="wrapper">
  <div class="stack">
    <div class="stage" id="stage">
      <img class="couch" src="couch.png" alt="couch" draggable="false" />
      <img class="fire"  id="fire"  src="fire_1.png"  alt="fire"  draggable="false" />
      <img class="smoke" id="smoke" src="smoke_1.png" alt="smoke" draggable="false" />
    </div>

    <div class="status" id="status">click / tap to ignite</div>
  </div>
</div>

<!-- MP3s live in the same folder as this HTML -->
<audio id="igniteEl"  src="ignite.mp3"  preload="auto" playsinline></audio>
<audio id="crackleEl" src="crackle.mp3" preload="auto" loop playsinline></audio>

<script>
/* -------------------------------------------------------
   VISUALS (unchanged vibe)
------------------------------------------------------- */
const stageEl  = document.getElementById("stage");
const fireEl   = document.getElementById("fire");
const smokeEl  = document.getElementById("smoke");
const statusEl = document.getElementById("status");

/* FRAMES */
const fireFrames = [
  "fire_1.png","fire_2.png","fire_3.png","fire_4.png","fire_5.png","fire_6.png","fire_7.png"
];
const smokeFrames = ["smoke_1.png","smoke_2.png","smoke_3.png"];

/* TIMING */
const FIRE_MS  = 110;
const SMOKE_MS = 220;

let holding = false;

let fireTimer = null;
let fireIndex = 0;

let smokeTimer = null;
let smokeIndex = 0;
let smokeY = 0;

let stopSmokeTimeout = null;

/* FIRE */
function startFire() {
  if (fireTimer) return;

  statusEl.textContent = "burning...";
  fireEl.style.opacity = "1";

  fireIndex = Math.floor(Math.random() * fireFrames.length);
  fireEl.src = fireFrames[fireIndex];

  fireTimer = setInterval(() => {
    fireIndex = (fireIndex + 1) % fireFrames.length;
    fireEl.src = fireFrames[fireIndex];

    const jx = (Math.random() < 0.35) ? (Math.random() < 0.5 ? -1 : 1) : 0;
    const jy = (Math.random() < 0.25) ? (Math.random() < 0.5 ? -1 : 1) : 0;
    fireEl.style.transform = `translate(${jx}px, ${jy}px)`;
  }, FIRE_MS);
}

function stopFire() {
  statusEl.textContent = "click / tap to ignite";
  fireEl.style.opacity = "0";
  fireEl.style.transform = "translate(0px, 0px)";

  clearInterval(fireTimer);
  fireTimer = null;
}

/* SMOKE */
function startSmoke() {
  if (stopSmokeTimeout) {
    clearTimeout(stopSmokeTimeout);
    stopSmokeTimeout = null;
  }
  if (smokeTimer) return;

  smokeEl.style.opacity = "1";
  smokeY = 0;

  smokeIndex = Math.floor(Math.random() * smokeFrames.length);
  smokeEl.src = smokeFrames[smokeIndex];

  smokeTimer = setInterval(() => {
    smokeIndex = (smokeIndex + 1) % smokeFrames.length;
    smokeEl.src = smokeFrames[smokeIndex];

    if (Math.random() < 0.75) smokeY -= 1;
    if (smokeY < -10) smokeY = 0;

    const sx = (Math.random() < 0.15) ? (Math.random() < 0.5 ? -1 : 1) : 0;
    smokeEl.style.transform = `translate(${sx}px, ${smokeY}px)`;
  }, SMOKE_MS);
}

function stopSmokeWithLinger() {
  if (stopSmokeTimeout) clearTimeout(stopSmokeTimeout);

  stopSmokeTimeout = setTimeout(() => {
    smokeEl.style.opacity = "0";
    smokeEl.style.transform = "translate(0px, 0px)";

    clearInterval(smokeTimer);
    smokeTimer = null;
    stopSmokeTimeout = null;
  }, 300);
}

/* -------------------------------------------------------
   AUDIO (BEST PRACTICE FOR MOST USERS)
   - WebAudio for reliable one-shot + loop, low latency
   - Fallback to HTMLAudio if WebAudio fails
   - Crackle is volume-gated so it is "only on while holding"
------------------------------------------------------- */
const igniteEl  = document.getElementById("igniteEl");
const crackleEl = document.getElementById("crackleEl");

let audioMode = "none"; // "webaudio" | "htmlaudio" | "none"
let audioReady = false;

/* WebAudio nodes */
let ctx = null;
let masterGain = null;

let igniteBuffer = null;
let crackleBuffer = null;

let crackleSource = null; // looping source
let crackleGain = null;   // volume gate for loop

/* Simple limiter-ish (prevents nasty peaks) */
let compressor = null;

function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

async function fetchArrayBuffer(url) {
  const res = await fetch(url, { cache: "force-cache" });
  if (!res.ok) throw new Error("Fetch failed: " + url);
  return await res.arrayBuffer();
}

async function decode(ctx, arrayBuffer) {
  // Safari sometimes needs decodeAudioData callback style, but modern supports promise
  return await ctx.decodeAudioData(arrayBuffer);
}

async function initWebAudioFromGesture() {
  if (audioReady) return;

  try {
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    if (!AudioCtx) throw new Error("No AudioContext");

    ctx = new AudioCtx();

    // must resume inside gesture for iOS
    if (ctx.state === "suspended") await ctx.resume();

    masterGain = ctx.createGain();
    masterGain.gain.value = 1.0;

    compressor = ctx.createDynamicsCompressor();
    compressor.threshold.value = -18;
    compressor.knee.value = 12;
    compressor.ratio.value = 6;
    compressor.attack.value = 0.003;
    compressor.release.value = 0.12;

    masterGain.connect(compressor);
    compressor.connect(ctx.destination);

    // Load & decode both sounds
    const [igniteAB, crackleAB] = await Promise.all([
      fetchArrayBuffer("ignite.mp3"),
      fetchArrayBuffer("crackle.mp3"),
    ]);

    [igniteBuffer, crackleBuffer] = await Promise.all([
      decode(ctx, igniteAB),
      decode(ctx, crackleAB),
    ]);

    // Crackle loop setup (volume-gated)
    crackleGain = ctx.createGain();
    crackleGain.gain.value = 0.0; // off until holding
    crackleGain.connect(masterGain);

    crackleSource = ctx.createBufferSource();
    crackleSource.buffer = crackleBuffer;
    crackleSource.loop = true;
    crackleSource.connect(crackleGain);
    crackleSource.start(0);

    audioMode = "webaudio";
    audioReady = true;
    return;
  } catch (err) {
    // If WebAudio fails for any reason, fall back to HTMLAudio
    initHTMLAudioFromGesture();
  }
}

function initHTMLAudioFromGesture() {
  if (audioReady) return;

  // prime crackle (silent) so it becomes instant later
  crackleEl.volume = 0;
  crackleEl.currentTime = 0;

  crackleEl.play().then(() => {
    // immediately silence (already 0) and keep it "alive"
    crackleEl.pause();
    crackleEl.currentTime = 0;
    audioMode = "htmlaudio";
    audioReady = true;
  }).catch(() => {
    // even if this fails, we still attempt later; but we won't claim ready
    audioMode = "none";
    audioReady = false;
  });
}

/* Play ignite */
function audioIgnite() {
  if (!audioReady) return;

  if (audioMode === "webaudio") {
    // one-shot buffer source (most reliable)
    const src = ctx.createBufferSource();
    src.buffer = igniteBuffer;

    const g = ctx.createGain();
    g.gain.value = 1.0;

    src.connect(g);
    g.connect(masterGain);

    src.start(0);
    return;
  }

  if (audioMode === "htmlaudio") {
    // clone trick = more reliable retrigger on iOS
    const oneShot = igniteEl.cloneNode(true);
    oneShot.volume = 1.0;
    oneShot.play().catch(() => {});
  }
}

/* Crackle ON/OFF (instant volume gating) */
function audioCrackleOn() {
  if (!audioReady) return;

  if (audioMode === "webaudio") {
    // quick ramp avoids clicks, still feels instant
    const t = ctx.currentTime;
    crackleGain.gain.cancelScheduledValues(t);
    crackleGain.gain.setValueAtTime(crackleGain.gain.value, t);
    crackleGain.gain.linearRampToValueAtTime(0.70, t + 0.015);
    return;
  }

  if (audioMode === "htmlaudio") {
    // start loop and set volume
    crackleEl.volume = 0.70;
    crackleEl.play().catch(() => {});
  }
}

function audioCrackleOff() {
  if (!audioReady) return;

  if (audioMode === "webaudio") {
    const t = ctx.currentTime;
    crackleGain.gain.cancelScheduledValues(t);
    crackleGain.gain.setValueAtTime(crackleGain.gain.value, t);
    crackleGain.gain.linearRampToValueAtTime(0.0, t + 0.015);
    return;
  }

  if (audioMode === "htmlaudio") {
    // show-stoppingly fast "off"
    crackleEl.volume = 0;
    // optional: pause a bit later to reduce iOS weirdness
    setTimeout(() => {
      crackleEl.pause();
      crackleEl.currentTime = 0;
    }, 120);
  }
}

/* -------------------------------------------------------
   INPUT (Pointer Events)
------------------------------------------------------- */
document.addEventListener("contextmenu", (e) => e.preventDefault());

function onDown(e) {
  e.preventDefault();
  holding = true;

  // BEST reliability: init audio inside the gesture
  // (If already ready, this is a no-op)
  initWebAudioFromGesture();

  // Make "press = immediate sound + visuals"
  audioIgnite();
  audioCrackleOn();

  startFire();

  setTimeout(() => {
    if (holding) startSmoke();
  }, 120);
}

function onUp(e) {
  if (e) e.preventDefault();
  holding = false;

  stopFire();
  stopSmokeWithLinger();

  // "Only on while holding" = instant off
  audioCrackleOff();
}

stageEl.addEventListener("pointerdown", onDown, { passive: false });
window.addEventListener("pointerup", onUp, { passive: false });
window.addEventListener("pointercancel", onUp, { passive: false });
window.addEventListener("pointerleave", onUp, { passive: false });

function goBack() {
  window.location.href = "../index.html";
}
</script>
</body>
</html>
