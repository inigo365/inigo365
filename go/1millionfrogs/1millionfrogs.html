<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>1millionfrogs</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<link rel="icon" type="image/png" href="../../images/icon.png">

<style>
@font-face{
  font-family:"RuneScape UF";
  src:url("../../fonts/RuneScape-UF.woff2") format("woff2"),
      url("../../fonts/RuneScape-UF.woff") format("woff");
}

html{ background:#fff; height:100%; }
body{ background:#fff; min-height:100%; }

html,body{
  margin:0; padding:0; width:100%;
  height:100vh; height:100svh; height:100dvh;
  font-family:"RuneScape UF", Arial, sans-serif;
  -webkit-user-select:none; user-select:none;
  -webkit-touch-callout:none;
  -webkit-tap-highlight-color:transparent;
  -webkit-text-size-adjust:100%;
  touch-action:manipulation;
}
html, body { cursor: url("../../images/cursor/cursor.png"), auto; }
button, input { cursor: url("../../images/cursor/cursor-hover.png"), pointer; }

:root{
  --accent:#2d93ea;
  --btn:#000;
  --gold: rgba(255, 215, 0, 0.95);
}

#c{
  position:fixed; inset:0; display:block;
  touch-action:none;
}

/* ===== UI ===== */
.topbar{
  position:fixed; top:8px; left:8px; right:8px;
  display:flex; align-items:flex-start; justify-content:flex-start;
  gap:10px;
  z-index:30;
  pointer-events:none;
}

.ui{ pointer-events:auto; }

.back-button{
  pointer-events:auto;
  font-size:28px; background:transparent; border:none;
  color:var(--accent);
  font-family:"RuneScape UF", Arial, sans-serif;
  text-transform:lowercase; padding:0;
}
.back-button:hover{ text-decoration:underline; }

.panel{
  pointer-events:auto;
  border:2px solid #000;
  background:#fff;
  padding:10px 12px;
  box-sizing:border-box;
  width: min(560px, calc(100vw - 16px));
}

.panel-title{
  font-size: clamp(20px, 4.5vw, 26px);
  text-transform:lowercase;
  margin-bottom:6px;
}

.panel-sub{
  font-size: clamp(14px, 3.6vw, 18px);
  text-transform:lowercase;
  line-height:1.25;
}

.linkish{
  font-family:"RuneScape UF", Arial, sans-serif;
  background:transparent;
  border:none;
  color:var(--btn);
  font-size: clamp(18px, 4vw, 22px);
  padding:0;
  text-transform:lowercase;
}
.linkish:hover{ text-decoration:underline; }

.stat{
  font-size: clamp(14px, 3.6vw, 18px);
  text-transform:lowercase;
  font-variant-numeric: tabular-nums;
}

.row{
  margin-top:8px;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  flex-wrap:wrap;
}

/* ===== Name overlay ===== */
.overlay{
  position:fixed; inset:0;
  background: rgba(255,255,255,0.98);
  display:flex;
  align-items:center;
  justify-content:center;
  z-index:9999;
}
.panel2{
  width:min(640px, calc(100vw - 24px));
  border:2px solid #000;
  padding:16px;
  background:#fff;
  text-align:center;
}
.panel2-title{ font-size:30px; text-transform:lowercase; margin-bottom:10px; }
.panel2-sub{
  font-size:18px;
  text-transform:lowercase;
  line-height:1.35;
  margin-bottom:12px;
}
.name-row{
  display:flex;
  gap:10px;
  justify-content:center;
  flex-wrap:wrap;
  align-items:center;
}
.name-row input{
  font-family:"RuneScape UF", Arial, sans-serif;
  font-size:22px;
  padding:8px 12px;
  border:2px solid #000;
  background:#fff;
  outline:none;
  border-radius:0;
  -webkit-appearance:none;
  appearance:none;
  text-transform:lowercase;
  width:min(320px, calc(100vw - 160px));
}
.boxbtn{
  font-family:"RuneScape UF", Arial, sans-serif;
  font-size:20px;
  padding:8px 14px;
  border:2px solid #000;
  background:#fff;
  text-transform:lowercase;
  color:var(--btn);
}
.hint{
  margin-top:10px;
  font-size:16px;
  text-transform:lowercase;
  opacity:0.9;
}

/* ===== Music toggle ===== */
.music-toggle{
  position:fixed;
  left:8px;
  bottom:8px;
  z-index:35;
  font-family:"RuneScape UF", Arial, sans-serif;
  font-size:20px;
  padding:6px 10px;
  border:2px solid #000;
  background:#fff;
  text-transform:lowercase;
  color:var(--btn);
}
.music-toggle:hover{ text-decoration:underline; }

@media (max-width: 760px){
  .topbar{
    flex-direction:column;
    align-items:flex-start;
    gap:8px;
  }
}
.pause-overlay{
  position:fixed; inset:0;
  background: rgba(255,255,255,0.70);
  display:none;
  align-items:center;
  justify-content:center;
  z-index:9000; /* above game, below name overlay (9999) */
  pointer-events:auto;
}

.pause-box{
  border:2px solid #000;
  background:#fff;
  padding:14px 18px;
  font-family:"RuneScape UF", Arial, sans-serif;
  font-size:28px;
  text-transform:lowercase;
  text-align:center;
}

.pause-sub{
  display:block;
  margin-top:6px;
  font-size:16px;
  opacity:0.85;
}

.pause-toggle{
  position:fixed;
  right:8px;
  bottom:8px;
  z-index:35;
  font-family:"RuneScape UF", Arial, sans-serif;
  font-size:20px;
  padding:6px 10px;
  border:2px solid #000;
  background:#fff;
  text-transform:lowercase;
  color:var(--btn);
}
.pause-toggle:hover{ text-decoration:underline; }

/* ===== overlay back button ===== */
.overlay-back{
  position: fixed;
  top: 8px;
  left: 8px;
  z-index: 10000;
}
/* ===== Mobile controls (joystick + boost) ===== */
.mobile-controls{
  position:fixed;
  left:0; right:0; bottom:8px;
  z-index:36;
  display:none;               /* only show on mobile via CSS media */
  pointer-events:none;
}

/* only show on touch/coarse pointer */
@media (pointer: coarse){
  .mobile-controls{ display:block; }
}

/* --- joystick container --- */
.joy{
  position:fixed;
  left:50%;
  bottom:10px;
  transform:translateX(-50%);
  width:132px;
  height:132px;
  pointer-events:auto;
  touch-action:none;
}

/* beige base like arcade housing */
.joy-base{
  position:absolute;
  inset:0;
  background:#e9e2c9;
  border:4px solid #000;
  box-sizing:border-box;
  /* chunky/pixel vibe */
  border-radius:0;
  box-shadow:
    4px 4px 0 rgba(0,0,0,0.22),
    8px 8px 0 rgba(0,0,0,0.10);
}

/* “plate” the stem comes out of */
.joy-plate{
  position:absolute;
  left:18px; right:18px;
  bottom:18px;
  height:34px;
  background:#f5f1e5;
  border:4px solid #000;
  box-sizing:border-box;
  z-index:4;
  overflow:hidden;
  box-shadow:
    inset 4px 4px 0 rgba(255,255,255,0.25),
    inset -4px -4px 0 rgba(0,0,0,0.12);
}

/* anchor point for stem/ball */
.joy-handle{
  position:absolute;
  left:50%;
  bottom:26px;          /* where stem emerges */
  width:0;
  height:0;
  transform:translateX(-50%);
  z-index:3;
}

/* stem: anchored, only LEANS */
.joy-stem{
  position:absolute;
  left:50%;
  bottom:-10px;         /* tuck into plate */
  width:14px;
  height:50px;
  transform:translateX(-50%) rotate(var(--stem-rot, 0deg));
  transform-origin: 50% 100%;
  background:#d9d9d9;
  border:4px solid #000;
  box-sizing:border-box;
  box-shadow:
    inset 4px 4px 0 rgba(255,255,255,0.18),
    inset -4px -4px 0 rgba(0,0,0,0.12);
}

/* knob: moves in an ellipse, stays centered via calc(-50% + dx) */
.joy-ball{
  position:absolute;
  left:50%;
  bottom:42px;
  width:44px;
  height:44px;

  /* ✅ this keeps the original centering AND adds joystick movement */
  transform:translate(
    calc(-50% + var(--joy-dx, 0px)),
    calc(var(--joy-dy, 0px))
  );

  background:#d63a3a;
  border:4px solid #000;
  box-sizing:border-box;

  /* pixel feel: no smooth rounding */
  border-radius:0;
  image-rendering: pixelated;

  box-shadow:
    inset -8px -8px 0 rgba(0,0,0,0.18),
    inset  6px  6px 0 rgba(255,255,255,0.16),
    4px 4px 0 rgba(0,0,0,0.20);
}

/* --- boost button: arcade red button --- */
.boost-btn{
  position:fixed;
  left:10px;
  bottom:64px;
  z-index:36;
  pointer-events:auto;

  width:78px;
  height:78px;

  border:4px solid #000;
  background:#d63a3a;
  color:#000;

  font-family:"RuneScape UF", Arial, sans-serif;
  font-size:20px;
  text-transform:lowercase;

  border-radius:0;
  box-shadow:
    inset -8px -8px 0 rgba(0,0,0,0.18),
    inset  6px  6px 0 rgba(255,255,255,0.16),
    4px 4px 0 rgba(0,0,0,0.22),
    8px 8px 0 rgba(0,0,0,0.10);

  display:flex;
  align-items:center;
  justify-content:center;

  -webkit-tap-highlight-color:transparent;
  user-select:none;
  touch-action:none;
}
.boost-btn:active{
  transform: translateY(2px);
}

/* only show on touch/coarse pointer */
@media (pointer: coarse){
  .mobile-controls{ display:block; }
}

</style>
</head>

<body>
<canvas id="c"></canvas>

<div class="topbar" id="topbar">
  <div class="ui">
    <button class="back-button" id="backBtn">← back</button>

    <div class="panel" id="playPanel">
      <div class="panel-title">1millionfrogs</div>
      <div class="panel-sub">
        keep finger down to steer<br>
        boost: space (desktop) • two fingers (mobile)
      </div>
      <div class="row">
        <button class="linkish" id="resetBtn" type="button">reset</button>
        <div class="stat" id="stats">length: 0 • eaten: 0 • boost: off</div>
      </div>
    </div>
  </div>
</div>

<div class="overlay" id="nameOverlay" aria-hidden="false">
  <button class="back-button overlay-back" id="backBtnOverlay">← back</button>

  <div class="panel2" role="dialog" aria-modal="true" aria-label="name entry">
    <div class="panel2-title">enter name</div>
    <div class="panel2-sub">there are big frogs out there already. catch them.</div>
    <div class="name-row">
      <input id="nameInput" autocomplete="off" autocapitalize="none" autocorrect="off" spellcheck="false" placeholder="name">
      <button class="boxbtn" id="startBtn" type="button">start</button>
    </div>
    <div class="hint">tip: boosting sheds mass behind you</div>
  </div>
</div>
<div class="pause-overlay" id="pauseOverlay" aria-hidden="true">
  <div class="pause-box">
    paused<br>
    <span class="pause-sub">tap to resume</span>
  </div>
</div>

<button class="music-toggle" id="musicBtn" type="button">music: on</button>
<button class="pause-toggle" id="pauseBtn" type="button">pause game</button>
<div class="mobile-controls" id="mobileControls" aria-hidden="true">
  <button class="boost-btn" id="boostBtn" type="button">boost</button>

  <div class="joy" id="joy">
    <div class="joy-base"></div>
    <div class="joy-plate"></div>

    <div class="joy-handle">
      <div class="joy-stem" id="joyStem"></div>
      <div class="joy-ball" id="joyBall"></div>
    </div>
  </div>
</div> <!-- ✅ CLOSE mobile-controls -->

<script>
/* iOS pinch prevention + no context menu */
document.addEventListener("gesturestart", (e) => e.preventDefault(), { passive:false });
document.addEventListener("gesturechange", (e) => e.preventDefault(), { passive:false });
document.addEventListener("gestureend", (e) => e.preventDefault(), { passive:false });
document.addEventListener("contextmenu", e => e.preventDefault());

const c = document.getElementById("c");
const ctx = c.getContext("2d", { alpha:false });

const statsEl = document.getElementById("stats");
const backBtn = document.getElementById("backBtn");
const backBtnOverlay = document.getElementById("backBtnOverlay");
const nameOverlay = document.getElementById("nameOverlay");
const nameInput = document.getElementById("nameInput");
const startBtn  = document.getElementById("startBtn");
const resetBtn  = document.getElementById("resetBtn");
const pauseBtn  = document.getElementById("pauseBtn");
const pauseOverlay = document.getElementById("pauseOverlay");
const mobileControls = document.getElementById("mobileControls");
const joy = document.getElementById("joy");
const joyStem = document.getElementById("joyStem");
const joyBall = document.getElementById("joyBall");
const boostBtn = document.getElementById("boostBtn");

pauseOverlay.addEventListener("pointerdown", (e)=>{
  e.preventDefault();
  if(paused) setPaused(false);
}, { passive:false });

backBtn.addEventListener("click", ()=>{
  setPaused(true);
  nameOverlay.style.display = "flex";
  nameOverlay.setAttribute("aria-hidden","false");
  try{ nameInput.focus(); }catch{}
});

// overlay back = go back to /go
backBtnOverlay.addEventListener("click", ()=> history.back());


/* =========================================================
   ASSETS
========================================================= */
const BG_SRC    = "assets/realm1.jpg";
const MUSIC_SRC = "assets/1millionfrogs.mp3";
const SFX_DIE_SRC  = "assets/sfx_die.mp3";
const SFX_GOLD_SRC = "assets/sfx_gold.mp3";

/* =========================================================
   SETTINGS
========================================================= */
const SETTINGS = {
  bots: 13,

  pelletTarget: 1200,
  segSpacing: 14,
  maxSegPoints: 220,

  baseSpeed: 175,
  turnSmooth: 10.0,

  boostSpeedMul: 1.55,
  boostDrainPerSec: 52,
  boostDropEvery: 0.13,

  headBodyHitMul: 0.85,
  cellSize: 110,

  // spawning feel (middle ground)
  botSpawnMinR: 1200,
  botSpawnRandR: 9000,

  respawnMinR: 2200,
  respawnRandR: 7000,

  midGiants: 3,
  midLenMin: 3000,
  midLenMax: 8000,

  // big “starter giants”
  starterGiants: 4,
  giantLenMin: 10000,
  giantLenMax: 20000,
};

const MAX_HUNTERS = 1; // try 1–3
let huntersNow = 0;
/* =========================================================
   CANVAS
========================================================= */
let dpr=1, W=0, H=0;
function resize(){
  dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  W = innerWidth; H = innerHeight;
  c.width = Math.floor(W*dpr);
  c.height = Math.floor(H*dpr);
  c.style.width = W+"px";
  c.style.height = H+"px";
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
addEventListener("resize", resize);
resize();

/* =========================================================
   IMAGES
========================================================= */
const bgImg = new Image();
bgImg.decoding = "async";
bgImg.src = BG_SRC;

/* =========================================================
   MUSIC
========================================================= */
const musicBtn = document.getElementById("musicBtn");
const music = new Audio(MUSIC_SRC);
music.loop = true;
music.preload = "auto";
music.volume = 0.9;

let musicOn = true;
let musicUnlocked = false;

function stopMusic(){
  try{
    music.pause();
    music.currentTime = 0;
  }catch{}
}
window.addEventListener("pagehide", stopMusic);
window.addEventListener("beforeunload", stopMusic);
document.addEventListener("visibilitychange", ()=>{ if(document.hidden) stopMusic(); });

function updateMusicButton(){ musicBtn.textContent = musicOn ? "music: on" : "music: off"; }
async function tryStartMusic(){
  if(!musicOn) return;
  try{
    const p = music.play();
    if(p && typeof p.then === "function") await p;
    musicUnlocked = true;
  }catch{}
}

/* =========================================================
   SFX (WebAudio - iOS reliable)
========================================================= */
let sfxOn = true;

let audioCtx = null;
let sfxBuffers = { die:null, gold:null };
let sfxReady = false;


function getAudioCtx(){
  if(!audioCtx){
    const AC = window.AudioContext || window.webkitAudioContext;
    audioCtx = new AC();
  }
  return audioCtx;
}

async function loadSfxBuffer(url){
  const ctx = getAudioCtx();
  const res = await fetch(url);
  const arr = await res.arrayBuffer();
  return await ctx.decodeAudioData(arr);
}

async function initSfx(){
  if(sfxReady) return;
  try{
    // load + decode once
    const [dieBuf, goldBuf] = await Promise.all([
      loadSfxBuffer(SFX_DIE_SRC),
      loadSfxBuffer(SFX_GOLD_SRC)
    ]);
    sfxBuffers.die = dieBuf;
    sfxBuffers.gold = goldBuf;
    sfxReady = true;
  }catch(e){
    // if this fails, SFX just won’t play (but game keeps running)
    console.warn("SFX init failed:", e);
  }
}

// MUST be called from a real user gesture (pointerdown/touchstart/click/keydown)
async function unlockAudio(){
  // resume audio context
  const ctx = getAudioCtx();
  if(ctx.state !== "running"){
    try{ await ctx.resume(); }catch(e){}
  }

  // start music (your existing behavior)
  tryStartMusic();

  // load sfx (can happen after resume)
  initSfx();
}

function playSfx(name, vol = 1){
  if(!sfxOn) return;
  const ctx = getAudioCtx();
  if(ctx.state !== "running") return;     // not unlocked yet
  const buf = sfxBuffers[name];
  if(!buf) return;                        // not loaded yet

  try{
    const src = ctx.createBufferSource();
    src.buffer = buf;

    const gain = ctx.createGain();
    gain.gain.value = vol;

    src.connect(gain);
    gain.connect(ctx.destination);

    src.start(0);
  }catch(e){}
}

const SFX = {
  die(){  playSfx("die", 0.95); },
  gold(){ playSfx("gold", 0.85); },
};

function setMusic(on){
  musicOn = !!on;
  updateMusicButton();
  if(!musicOn){ try{ music.pause(); }catch{} }
  else { tryStartMusic(); }
}
musicBtn.addEventListener("pointerdown", (e)=>{
  e.preventDefault();
  unlockAudio();
  setMusic(!musicOn);
});
// unlock on first interaction anywhere
window.addEventListener("pointerdown", unlockAudio, { capture:true });
window.addEventListener("touchstart", unlockAudio, { capture:true, passive:true });
window.addEventListener("keydown", unlockAudio, { capture:true });

// ALSO unlock when they press Start (super reliable)
startBtn.addEventListener("pointerdown", unlockAudio, { capture:true });
startBtn.addEventListener("touchstart", unlockAudio, { capture:true, passive:true });

updateMusicButton();

/* =========================================================
   BOT NAMES + COLORS
========================================================= */
const FROG_NAMES = [
  "sir croaks-a-lot","lady lily","moss wizard","pond prophet","bog baron",
  "tadpole tycoon","ribbit mcgee","hops mcgloats","toadstool oracle","lilypad duchess",
  "swamp prince","mud maven","marshmallow toad","feral frogling","croak noir",
  "mr blorbo","slime saint","kermits cousin","the damp one","frog of war",
  "bloop pope","green accountant","soggy knight","mystic gunk","hollow croak",
  "fizz bishop","lilypad librarian","glorp champion","gumbo ghost","muck angel",
  "pondwraith","bog gossiper","croak whisperer","moss boss","wet prophet",
  "springleaf","dungeon tad","the polite toad","swamp couture","ribbit rex",
  "mild menace","drippy duke","marsh mirage","chonk toad","slurp wizard",
  "frogbeard","inkblot frog","silt emperor","mire cherub","glitter toad"
];

const FROG_COLORS = [
  "#37b45a",
  "#4aa8ff",
  "#ff6b6b",
  "#ffd93d",
  "#9b59b6",
  "#1abc9c",
  "#e67e22",
];

function pickName(used){
  for(let i=0;i<16;i++){
    const n = FROG_NAMES[(Math.random()*FROG_NAMES.length)|0];
    if(!used.has(n)) return n;
  }
  return FROG_NAMES[(Math.random()*FROG_NAMES.length)|0];
}
/* =========================================================
   WORLD + RNG
========================================================= */
const WORLD = { seed: 1337, pellets: [] };
let golden = [];                 // can hold multiple gold pellets
const GOLDEN_MAX = 10;          // total gold pellets allowed in the active area (try 4–10)
const GOLDEN_CHANCE = 0.028;   // ~1.2% of spawned pellets become gold (try 0.008–0.02)

/* =========================================================
   HELPERS
========================================================= */

function rand01(n){
  let x = (n ^ WORLD.seed) >>> 0;
  x = Math.imul(x ^ (x >>> 16), 2246822507);
  x = Math.imul(x ^ (x >>> 13), 3266489909);
  x = (x ^ (x >>> 16)) >>> 0;
  return x / 4294967296;
}
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function normAngle(a){
  while(a > Math.PI) a -= Math.PI*2;
  while(a < -Math.PI) a += Math.PI*2;
  return a;
}

/* =========================================================
   SPRITES (cached)
========================================================= */
function makeFrogSprite(size, variant, color){
  const s = document.createElement("canvas");
  s.width = s.height = size;
  const g = s.getContext("2d");

  const cx = size/2, cy = size/2, r = size*0.33;

  g.beginPath();
  g.arc(cx, cy, r, 0, Math.PI*2);
  if(variant === "gold"){
    g.fillStyle = "rgba(255, 215, 0, 0.95)";
  }else{
    g.fillStyle = color || "rgba(55, 180, 90, 0.95)";
  }
  g.fill();

  g.lineWidth = Math.max(2, size*0.05);
  g.strokeStyle = "rgba(0,0,0,0.35)";
  g.stroke();

  const ex = size*0.18, ey = size*0.18, er = size*0.09;
  g.beginPath();
  g.arc(cx - ex, cy - ey, er, 0, Math.PI*2);
  g.arc(cx + ex, cy - ey, er, 0, Math.PI*2);
  g.fillStyle = "rgba(240,240,240,0.95)";
  g.fill();
  g.strokeStyle = "rgba(0,0,0,0.30)";
  g.stroke();

  const pr = er*0.35;
  g.beginPath();
  g.arc(cx - ex, cy - ey, pr, 0, Math.PI*2);
  g.arc(cx + ex, cy - ey, pr, 0, Math.PI*2);
  g.fillStyle = "rgba(0,0,0,0.75)";
  g.fill();

  g.beginPath();
  g.arc(cx, cy + size*0.08, size*0.12, 0, Math.PI, false);
  g.strokeStyle = "rgba(0,0,0,0.25)";
  g.lineWidth = Math.max(2, size*0.03);
  g.stroke();

  if(variant === "gold"){
    g.save();
    g.globalAlpha = 0.9;
    g.strokeStyle = "rgba(255,255,255,0.9)";
    g.lineWidth = Math.max(2, size*0.035);
    const sx = size*0.22, sy = size*0.22;
    g.beginPath();
    g.moveTo(cx, sy); g.lineTo(cx, size-sy);
    g.moveTo(sx, cy); g.lineTo(size-sx, cy);
    g.stroke();
    g.restore();
  }
  return s;
}

function makeCrownSprite(size){
  const s = document.createElement("canvas");
  s.width = s.height = size;
  const g = s.getContext("2d");

  const pad = size*0.14, left = pad, right = size - pad;
  const top = size*0.20, baseY = size*0.74;

  g.fillStyle = "rgba(255, 215, 0, 0.95)";
  g.strokeStyle = "rgba(0,0,0,0.35)";
  g.lineWidth = Math.max(2, size*0.05);

  g.beginPath();
  g.moveTo(left, baseY);
  g.lineTo(left + (right-left)*0.20, top + (baseY-top)*0.35);
  g.lineTo(left + (right-left)*0.35, top);
  g.lineTo(left + (right-left)*0.50, top + (baseY-top)*0.32);
  g.lineTo(left + (right-left)*0.65, top);
  g.lineTo(left + (right-left)*0.80, top + (baseY-top)*0.35);
  g.lineTo(right, baseY);
  g.closePath();
  g.fill();
  g.stroke();

  g.beginPath();
  g.roundRect(left, baseY - size*0.16, right-left, size*0.18, size*0.05);
  g.fillStyle = "rgba(255, 200, 0, 0.95)";
  g.fill();
  g.stroke();

  g.fillStyle = "rgba(45, 147, 234, 0.9)";
  const gemR = size*0.05;
  g.beginPath();
  g.arc(left + (right-left)*0.33, baseY - size*0.10, gemR, 0, Math.PI*2);
  g.arc(left + (right-left)*0.50, baseY - size*0.10, gemR, 0, Math.PI*2);
  g.arc(left + (right-left)*0.67, baseY - size*0.10, gemR, 0, Math.PI*2);
  g.fill();

  return s;
}

const SPRITE_CACHE = new Map();
function getSnakeSprite(size, color, gold){
  const key = `${size}_${color}_${gold}`;
  let spr = SPRITE_CACHE.get(key);
  if(spr) return spr;
  spr = makeFrogSprite(size, gold ? "gold" : "normal", color);
  SPRITE_CACHE.set(key, spr);
  return spr;
}

const SPRITES = {
  pellet: makeFrogSprite(34, "normal", "#37b45a"),
  pelletSmall: makeFrogSprite(26, "normal", "#37b45a"),
  gold: makeFrogSprite(56, "gold"),
  crown: makeCrownSprite(56),
};

/* =========================================================
   INPUT (smooth iOS: 1 finger steers; 2 fingers boosts)
========================================================= */
// mobile detection (keeps desktop unchanged)
const IS_MOBILE = matchMedia("(pointer: coarse)").matches || ("ontouchstart" in window);

// joystick state
let joyActive = false;
let joyId = null;
let joyVec = { x: 0, y: 0 }; // -1..1
const JOY_RADIUS = 24;       // pixels the stick can move (feel free: 20-30)

const JOY_RAD_X = 26;   // ellipse travel (feel free: 22–30)
const JOY_RAD_Y = 18;
const PIXEL_STEP = 2;   // snap to grid for chunky movement

function snapPx(v){
  return Math.round(v / PIXEL_STEP) * PIXEL_STEP;
}

function setJoyVisual(nx, ny){
  // ellipse travel
  let px = nx * JOY_RAD_X;
  let py = ny * JOY_RAD_Y;

  // snap = chunky/pixel movement
  px = snapPx(px);
  py = snapPx(py);

  // ✅ move knob via CSS vars (does NOT overwrite centering)
  joyBall.style.setProperty("--joy-dx", `${px}px`);
  joyBall.style.setProperty("--joy-dy", `${py}px`);

  // stem leans toward knob (small degrees)
  const ang = Math.atan2(py, px);              // radians
  const deg = ang * 180 / Math.PI;

  const mag = Math.min(1, Math.hypot(px, py) / Math.max(JOY_RAD_X, JOY_RAD_Y));
  const lean = 10 + mag * 10;                  // 10–20 degrees-ish

  // rotate toward direction, but keep it “physical”
  joyStem.style.setProperty("--stem-rot", `${deg * (lean/20)}deg`);
}

function resetJoy(){
  joyVec.x = 0;
  joyVec.y = 0;
  joyActive = false;
  joyId = null;

  joyBall.style.setProperty("--joy-dx", `0px`);
  joyBall.style.setProperty("--joy-dy", `0px`);
  joyStem.style.setProperty("--stem-rot", `0deg`);
}

if(IS_MOBILE){
  // show container for accessibility state
  mobileControls.setAttribute("aria-hidden", "false");

  joy.addEventListener("pointerdown", (e)=>{
    if(paused) return;
    e.preventDefault();
    joyActive = true;
    joyId = e.pointerId;
    joy.setPointerCapture(joyId);

    const r = joy.getBoundingClientRect();
    const cx = r.left + r.width/2;
    const cy = r.top + r.height/2;

    const dx = e.clientX - cx;
    const dy = e.clientY - cy;

    const len = Math.hypot(dx,dy) || 1;
    const max = JOY_RADIUS;
    const k = Math.min(1, len / max);

    const nx = (dx / len) * k;
    const ny = (dy / len) * k;

    joyVec.x = nx;
    joyVec.y = ny;
    setJoyVisual(nx, ny);
  }, { passive:false });

  joy.addEventListener("pointermove", (e)=>{
    if(!joyActive || e.pointerId !== joyId) return;
    if(paused) return;
    e.preventDefault();

    const r = joy.getBoundingClientRect();
    const cx = r.left + r.width/2;
    const cy = r.top + r.height/2;

    const dx = e.clientX - cx;
    const dy = e.clientY - cy;

    const len = Math.hypot(dx,dy) || 1;
    const max = JOY_RADIUS;
    const k = Math.min(1, len / max);

    const nx = (dx / len) * k;
    const ny = (dy / len) * k;

    joyVec.x = nx;
    joyVec.y = ny;
    setJoyVisual(nx, ny);
  }, { passive:false });

  joy.addEventListener("pointerup", (e)=>{
    if(e.pointerId !== joyId) return;
    e.preventDefault();
    resetJoy();
  }, { passive:false });

  joy.addEventListener("pointercancel", (e)=>{
    if(e.pointerId !== joyId) return;
    e.preventDefault();
    resetJoy();
  }, { passive:false });
}
if(IS_MOBILE){
  boostBtn.addEventListener("pointerdown", (e)=>{
    if(paused) return;
    e.preventDefault();
    boostHeld = true;
  }, { passive:false });

  boostBtn.addEventListener("pointerup", (e)=>{
    e.preventDefault();
    boostHeld = false;
  }, { passive:false });

  boostBtn.addEventListener("pointercancel", (e)=>{
    e.preventDefault();
    boostHeld = false;
  }, { passive:false });
}

let pointer = { x: W/2, y: H/2 };
let boostHeld = false;

c.addEventListener("touchstart", (e)=>{
  e.preventDefault();
  if(!IS_MOBILE){
  const t = e.touches[0];
  if(t){ pointer.x = t.clientX; pointer.y = t.clientY; }
}
  if(!IS_MOBILE) boostHeld = e.touches.length >= 2;
}, { passive:false });

c.addEventListener("touchmove", (e)=>{
  e.preventDefault();
  if(!IS_MOBILE){
  const t = e.touches[0];
  if(t){ pointer.x = t.clientX; pointer.y = t.clientY; }
}
  if(!IS_MOBILE) boostHeld = e.touches.length >= 2;
}, { passive:false });

c.addEventListener("touchend", (e)=>{
  e.preventDefault();
  if(!IS_MOBILE) boostHeld = e.touches.length >= 2;
}, { passive:false });

c.addEventListener("touchcancel", (e)=>{
  e.preventDefault();
  boostHeld = false;
}, { passive:false });

// mouse/pen fallback
c.addEventListener("pointerdown", (e)=>{
  if(e.pointerType === "touch") return;
  pointer.x = e.clientX; pointer.y = e.clientY;
  boostHeld = true;
});
c.addEventListener("pointermove", (e)=>{
  if(e.pointerType === "touch") return;
  pointer.x = e.clientX; pointer.y = e.clientY;
});
c.addEventListener("pointerup", (e)=>{
  if(e.pointerType === "touch") return;
  boostHeld = false;
});

// keyboard boost
document.addEventListener("keydown", (e)=>{ if(e.key === " "){ boostHeld = true; e.preventDefault(); } });
document.addEventListener("keyup",   (e)=>{ if(e.key === " "){ boostHeld = false; e.preventDefault(); } });

/* =========================================================
   GRID
========================================================= */
function cellKey(cx, cy){ return (cx<<16) ^ (cy & 0xffff); }
class Grid {
  constructor(cellSize){ this.cs = cellSize; this.map = new Map(); }
  clear(){ this.map.clear(); }
  _bucket(cx, cy){
    const k = cellKey(cx, cy);
    let b = this.map.get(k);
    if(!b){ b = []; this.map.set(k,b); }
    return b;
  }
  add(x,y,obj){
    const cx = (x / this.cs) | 0;
    const cy = (y / this.cs) | 0;
    this._bucket(cx,cy).push(obj);
  }
  query(x,y,rad, out){
    const cs = this.cs;
    const minX = ((x-rad)/cs)|0, maxX = ((x+rad)/cs)|0;
    const minY = ((y-rad)/cs)|0, maxY = ((y+rad)/cs)|0;
    for(let cy=minY; cy<=maxY; cy++){
      for(let cx=minX; cx<=maxX; cx++){
        const b = this.map.get(cellKey(cx,cy));
        if(!b) continue;
        for(let i=0;i<b.length;i++) out.push(b[i]);
      }
    }
  }
}
const pelletGrid = new Grid(SETTINGS.cellSize);
const bodyGrid   = new Grid(SETTINGS.cellSize);

/* =========================================================
   SNAKES
========================================================= */
function makeSnake(opts){
  const baseLen = opts.length || 120;
  return {
    id: opts.id,
    name: opts.name,
    isPlayer: !!opts.isPlayer,

    alive: true,
    respawnT: 0,
    respawnLen: opts.respawnLen ?? (opts.isPlayer ? baseLen : 160),

    x: opts.x || 0,
    y: opts.y || 0,
    angle: 0,
    targetAngle: 0,

    color: opts.color || FROG_COLORS[(Math.random() * FROG_COLORS.length) | 0],

    baseSpeed: SETTINGS.baseSpeed * (opts.speedMul ?? 1),
    speed: SETTINGS.baseSpeed,

    eaten: opts.eaten || 0,
    length: baseLen,
    radius: 10,

    body: [{x: opts.x || 0, y: opts.y || 0}],
    lastSegX: opts.x || 0,
    lastSegY: opts.y || 0,

    boost: false,
    boostDropT: 0,

   ai: {
    t: 0,
    targetX: 0,
    targetY: 0,
    wanderA: rand01(opts.id*999+11)*Math.PI*2,
    huntT: 0,
    huntCooldownT: 0
  }

  };
}
function updateRadius(s){ s.radius = clamp(10 + s.length / 190, 10, 34); }

const snakes = [];
let player = null;

function seedBody(s){
  const pts = Math.min(SETTINGS.maxSegPoints, Math.max(8, (s.length / SETTINGS.segSpacing)|0));
  const x = s.x, y = s.y;
  s.body = [];
  let px = x, py = y;
  let ang = rand01(s.id*99) * Math.PI*2;
  for(let k=0;k<pts;k++){
    s.body.push({x:px,y:py});
    ang += (rand01(s.id*123 + k*9)-0.5) * 0.35;
    px -= Math.cos(ang) * SETTINGS.segSpacing;
    py -= Math.sin(ang) * SETTINGS.segSpacing;
  }
  s.body[0] = {x,y};
  s.lastSegX = x;
  s.lastSegY = y;
}

function spawnPlayer(name){
  const s = makeSnake({
    id: 1,
    name: (name || "frog").toLowerCase().slice(0,18),
    isPlayer: true,
    x: 0, y: 0,
    length: 140,
    speedMul: 1.0,
    respawnLen: 140
  });
  updateRadius(s);
  seedBody(s);
  player = s;
  snakes.push(s);
}

function spawnBots(count, baseId, lengthMin, lengthMax, speedMin, speedMax, usedNames){
  for(let i=0;i<count;i++){
    const id = baseId + i;
    const a  = rand01(id*17) * Math.PI*2;
    const u  = rand01(id*23);                 // 0..1
    const r  = SETTINGS.botSpawnMinR + Math.pow(u, 0.65) * SETTINGS.botSpawnRandR;
    const x  = Math.cos(a)*r;
    const y  = Math.sin(a)*r;

    const len = lengthMin + rand01(id*31) * (lengthMax - lengthMin);
    const speedMul = speedMin + rand01(id*41) * (speedMax - speedMin);

    const nm = pickName(usedNames); usedNames.add(nm);

    const s = makeSnake({
      id,
      name: nm,
      x, y,
      length: len,
      speedMul,
      respawnLen: 160
    });
    s.eaten = Math.floor(len / 8);

    updateRadius(s);
    seedBody(s);
    snakes.push(s);
  }
}

function spawnWorldSnakes(){
  const used = new Set([player.name]);

  // starter giants
  spawnBots(SETTINGS.starterGiants, 200, SETTINGS.giantLenMin, SETTINGS.giantLenMax, 0.90, 1.05, used);

  spawnBots(SETTINGS.midGiants, 260, SETTINGS.midLenMin, SETTINGS.midLenMax, 0.92, 1.08, used);

  // regular bots
  spawnBots(SETTINGS.bots, 100, 180, 650, 0.92, 1.12, used);
}

/* =========================================================
   PELLETS
========================================================= */
function isWorldPointOnScreen(wx, wy, pad = 80){
  const z  = cam.z;
  const ox = W*0.5 - cam.x * z;
  const oy = H*0.5 - cam.y * z;

  const sx = wx * z + ox;
  const sy = wy * z + oy;

  return (sx >= -pad && sx <= W + pad && sy >= -pad && sy <= H + pad);
}

function ensurePellets(camX, camY){
  const target = SETTINGS.pelletTarget;
  const radius = 2600;

  while(WORLD.pellets.length < target){
    const j = WORLD.pellets.length + ((Math.random()*1e9)|0);
    const a = rand01(j+10) * Math.PI*2;
    const r = Math.sqrt(rand01(j+20)) * radius;
    const x = camX + Math.cos(a)*r + (rand01(j+30)-0.5)*180;
    const y = camY + Math.sin(a)*r + (rand01(j+40)-0.5)*180;

    // gold pellets spawn exactly like normal pellets, just rarer (and capped)
  if(golden.length < GOLDEN_MAX && Math.random() < GOLDEN_CHANCE){
    golden.push({ x, y, r: 26 });
    continue;
  }


    WORLD.pellets.push({ x, y, r: 16 });

    // your “cluster” burst (unchanged vibe)
    if(rand01(j+60) > 0.997){
      for(let k=0;k<5;k++){
        const aa = rand01(j+70+k)*Math.PI*2;
        const rr = 30 + rand01(j+80+k)*90;
        WORLD.pellets.push({ x: x + Math.cos(aa)*rr, y: y + Math.sin(aa)*rr, r: 16 });
      }
    }
  }

  const maxD = radius * 1.35;
  const maxD2 = maxD*maxD;

  // cull regular pellets
  let w=0;
  for(let i=0;i<WORLD.pellets.length;i++){
    const p = WORLD.pellets[i];
    const dx=p.x-camX, dy=p.y-camY;
    if(dx*dx+dy*dy < maxD2) WORLD.pellets[w++] = p;
  }
  WORLD.pellets.length = w;

  // cull golden pellets
  for(let i=golden.length-1;i>=0;i--){
    const g0 = golden[i];
    const dx=g0.x-camX, dy=g0.y-camY;
    if(dx*dx+dy*dy > maxD2) golden.splice(i, 1);
  }

}

function rebuildPelletGrid(){
  pelletGrid.clear();
  for(let i=0;i<WORLD.pellets.length;i++){
    pelletGrid.add(WORLD.pellets[i].x, WORLD.pellets[i].y, WORLD.pellets[i]);
  }
  for(const g of golden) pelletGrid.add(g.x, g.y, g);
}

/* =========================================================
   BODY
========================================================= */
function addBodyPointIfNeeded(s){
  const dx=s.x-s.lastSegX, dy=s.y-s.lastSegY;
  if(Math.hypot(dx,dy) < SETTINGS.segSpacing) return;
  s.lastSegX=s.x; s.lastSegY=s.y;
  s.body.unshift({x:s.x,y:s.y});
  if(s.body.length > SETTINGS.maxSegPoints) s.body.length = SETTINGS.maxSegPoints;
}
function trimBodyToLength(s){
  const b=s.body, target=s.length;
  while(b.length > 2){
    let t=0;
    for(let i=0;i<b.length-1;i++){
      const p=b[i], q=b[i+1];
      t += Math.hypot(p.x-q.x, p.y-q.y);
      if(t > target) break;
    }
    if(t <= target) break;
    b.pop();
  }
}

/* =========================================================
   MOVEMENT + BOOST
========================================================= */
function updateMovement(s, dt){
  if(!s.alive) return;

  let da = normAngle(s.targetAngle - s.angle);
  s.angle += da * Math.min(1, dt * SETTINGS.turnSmooth);

  if(s.isPlayer) s.boost = boostHeld && s.length > 110;

  const speedMul = s.boost ? SETTINGS.boostSpeedMul : 1.0;
  s.speed = s.baseSpeed * speedMul;

  s.x += Math.cos(s.angle) * s.speed * dt;
  s.y += Math.sin(s.angle) * s.speed * dt;

  if(s.boost){
    s.length = Math.max(70, s.length - SETTINGS.boostDrainPerSec * dt);
    s.boostDropT -= dt;
    if(s.boostDropT <= 0){
      s.boostDropT = SETTINGS.boostDropEvery;
      const bx = s.x - Math.cos(s.angle) * (s.radius * 2.3);
      const by = s.y - Math.sin(s.angle) * (s.radius * 2.3);
      WORLD.pellets.push({ x: bx, y: by, r: 16 });
      updateRadius(s);
    }
  }
}

/* =========================================================
   AI
========================================================= */
const tmpAvoidBodies = [];

function aiUpdate(s, dt){
  // safety for older snakes
  if(typeof s.ai.huntT !== "number") s.ai.huntT = 0;
  if(typeof s.ai.huntCooldownT !== "number") s.ai.huntCooldownT = 0;

  s.ai.t -= dt;
  if(s.ai.huntT > 0) s.ai.huntT = Math.max(0, s.ai.huntT - dt);
  if(s.ai.huntCooldownT > 0) s.ai.huntCooldownT = Math.max(0, s.ai.huntCooldownT - dt);

  // carry forward last target between decision ticks
  let tx = s.ai.targetX;
  let ty = s.ai.targetY;

  // === DECISION TICK (every ~0.25–0.8s) ===
  if(s.ai.t <= 0){
    s.ai.t = 0.25 + Math.random()*0.55;

    // wander baseline (keeps movement organic)
    tx = s.x + Math.cos(s.ai.wanderA) * 520;
    ty = s.y + Math.sin(s.ai.wanderA) * 520;
    s.ai.wanderA += (Math.random()-0.5) * 0.8;

    // seek pellets (soft preference)
    const n = WORLD.pellets.length;
    if(n > 0){
      let best=null, bestD2=Infinity;
      for(let i=0;i<14;i++){
        const p = WORLD.pellets[(Math.random()*n)|0];
        const dx=p.x-s.x, dy=p.y-s.y;
        const d2=dx*dx+dy*dy;
        if(d2 < bestD2){ bestD2=d2; best=p; }
      }
      if(best){
        // don't laser lock perfectly; bias toward it
        tx = tx*0.25 + best.x*0.75;
        ty = ty*0.25 + best.y*0.75;
      }
    }

    // seek nearest golden (if any) - stronger preference than normal pellets
    if(golden && golden.length){
      let bestG=null, bestGD2=Infinity;
      for(let i=0;i<golden.length;i++){
        const g0 = golden[i];
        const dx=g0.x-s.x, dy=g0.y-s.y;
        const d2=dx*dx+dy*dy;
        if(d2 < bestGD2){ bestGD2=d2; bestG=g0; }
      }
      if(bestG && bestGD2 < 1800*1800){
        tx = bestG.x;
        ty = bestG.y;
      }
    }

    // Decide whether to START hunting player (limited + not constant)
    if(player && player.alive && !s.isPlayer && s.ai.huntT <= 0 && s.ai.huntCooldownT <= 0){
      const dx = player.x - s.x, dy = player.y - s.y;
      const d2 = dx*dx + dy*dy;

      const bigger = (s.length > player.length * 1.25);
      const closeEnough = (d2 < 1500*1500);

      // only some bots, some of the time
      // (also uses global huntersNow/MAX_HUNTERS you already have)
      if(bigger && closeEnough && huntersNow < MAX_HUNTERS && Math.random() < 0.22){
        huntersNow++;

        // hunt lasts a short time, then they break off
        s.ai.huntT = 2.2 + Math.random()*1.6;      // ~2.2–3.8s
        s.ai.huntCooldownT = 3.5 + Math.random()*3.5; // ~3.5–7s (prevents constant trapping)
      }
    }

    // store targets
    s.ai.targetX = tx;
    s.ai.targetY = ty;

    // occasional boost (rare)
    if(!s.boost) s.boost = (s.length > 320 && Math.random() > 0.992);
  }

  // === HUNT OVERRIDE (more human: cutoff + orbit, then disengage) ===
  if(player && player.alive && s.ai.huntT > 0){
    const dx = player.x - s.x, dy = player.y - s.y;
    const d2 = dx*dx + dy*dy;
    const d  = Math.sqrt(d2);

    // if player is far, stop hunting early (reduces "endless same direction")
    if(d > 1900){
      s.ai.huntT = 0;
    }else{
      // cutoff target (lead ahead of player)
      const lead = clamp(220 + d*0.16, 220, 520);
      let px = player.x + Math.cos(player.angle) * lead;
      let py = player.y + Math.sin(player.angle) * lead;

      // orbit bias so it feels like real players passing / wrapping
      // (each bot keeps a consistent side during this hunt)
      const side = (rand01((s.id*7777)|0) < 0.5 ? -1 : 1);
      const off  = clamp(120 + d*0.05, 120, 260);
      px += -Math.sin(player.angle) * off * side;
      py +=  Math.cos(player.angle) * off * side;

      // add some imperfection so it's killable
      px += (Math.random()-0.5) * 120;
      py += (Math.random()-0.5) * 120;

      tx = px; ty = py;

      // hunting shouldn’t be boost-suicide
      s.boost = false;

      // keep stored target in sync
      s.ai.targetX = tx;
      s.ai.targetY = ty;
    }
  }else{
    tx = s.ai.targetX;
    ty = s.ai.targetY;
  }

  // === AVOIDANCE STEERING ===
  let ax=0, ay=0;
  let danger=0;

  // avoid player head if player is bigger (stops dumb head-ons)
  if(player && player.alive && player !== s && player.length > s.length * 1.05){
    const dx = s.x - player.x, dy = s.y - player.y;
    const d2 = dx*dx + dy*dy;
    if(d2 < 560*560){
      danger = 1;
      const inv = 1 / Math.max(1, Math.sqrt(d2));
      ax += dx * inv * 1.25;
      ay += dy * inv * 1.25;
    }
  }

  // avoid bigger heads
  for(let i=0;i<snakes.length;i++){
    const o = snakes[i];
    if(o===s || !o.alive) continue;
    if(o.length <= s.length * 1.08) continue;

    const dx = s.x - o.x, dy = s.y - o.y;
    const d2 = dx*dx + dy*dy;
    if(d2 < 560*560){
      danger = 1;
      const inv = 1 / Math.max(1, Math.sqrt(d2));
      ax += dx * inv * 1.8;
      ay += dy * inv * 1.8;
    }
  }

  // avoid nearby bodies
  tmpAvoidBodies.length = 0;
  bodyGrid.query(s.x, s.y, 160 + s.radius, tmpAvoidBodies);
  for(let i=0;i<tmpAvoidBodies.length;i++){
    const pt = tmpAvoidBodies[i];
    if(pt.sid === s.id) continue;
    const dx = s.x - pt.x, dy = s.y - pt.y;
    const d2 = dx*dx + dy*dy;
    if(d2 < 165*165){
      danger = 1;
      const inv = 1 / Math.max(1, Math.sqrt(d2));
      ax += dx * inv * 1.15;
      ay += dy * inv * 1.15;
    }
  }

  if(danger) s.boost = false;

  // === COMBINE GOAL + AVOIDANCE ===
  const vx = (tx - s.x) + ax*420;
  const vy = (ty - s.y) + ay*420;

  s.targetAngle = Math.atan2(vy, vx);

  // subtle organic wiggle (less for huge snakes)
  const wiggleAmt = 0.16 * clamp(1 - (s.length / 16000), 0.18, 1);
  s.targetAngle += Math.sin(performance.now()*0.0016 + s.id*13.37) * wiggleAmt;
}
/* =========================================================
   EATING
========================================================= */
const tmpNear = [];
function eatCheck(s){
  if(!s.alive) return;

  tmpNear.length = 0;
  const magnet = s.boost ? 60 : 0;
  pelletGrid.query(s.x, s.y, 80 + s.radius + magnet, tmpNear);

  for(let i=tmpNear.length-1;i>=0;i--){
    const p=tmpNear[i];
    const dx=p.x-s.x, dy=p.y-s.y;
    const rr=(s.radius + (p.r||18))*0.85;
    if(dx*dx+dy*dy > rr*rr) continue;

    const gi = golden.indexOf(p);
if(gi !== -1){
  golden.splice(gi, 1);
  if(s.isPlayer) SFX.gold();
  s.eaten += 8;             // your tuned reward
  s.length += 60;
  updateRadius(s);
  continue;
}

    p._dead = true;
    s.eaten++;
    s.length += 10;
    updateRadius(s);
  }
}
function compactPellets(){
  const arr=WORLD.pellets;
  let w=0;
  for(let i=0;i<arr.length;i++){
    const p=arr[i];
    if(p._dead){ p._dead=false; continue; }
    arr[w++] = p;
  }
  arr.length=w;
}

/* =========================================================
   COLLISION
========================================================= */
function rebuildBodyGrid(){
  bodyGrid.clear();
  for(let si=0; si<snakes.length; si++){
    const s=snakes[si];
    if(!s.alive) continue;
    const b=s.body;
    const start = Math.min(6, b.length);
    for(let i=start;i<b.length;i++){
      const pt=b[i];
      bodyGrid.add(pt.x, pt.y, { x:pt.x, y:pt.y, sid:s.id });
    }
  }
}

const tmpBodies = [];
function checkPop(s){
  if(!s.alive) return;

  // head-to-head (tighter + decisive)
  for(let i=0;i<snakes.length;i++){
    const o = snakes[i];
    if(o === s || !o.alive) continue;

    const dx = o.x - s.x, dy = o.y - s.y;
    const rr = (o.radius + s.radius) * 0.92;
    if(dx*dx + dy*dy < rr*rr){
      const eps = 18;
      if(s.length + eps < o.length) return popSnake(s);
      if(o.length + eps < s.length) return popSnake(o);
      popSnake(o);
      return popSnake(s);
    }
  }

  // head-to-body
  tmpBodies.length=0;
  bodyGrid.query(s.x, s.y, 80 + s.radius, tmpBodies);

  const hitR = s.radius * SETTINGS.headBodyHitMul;
  const hitR2 = hitR*hitR;

  for(let i=0;i<tmpBodies.length;i++){
    const pt=tmpBodies[i];
    if(pt.sid === s.id) continue;
    const dx=pt.x-s.x, dy=pt.y-s.y;
    if(dx*dx+dy*dy < hitR2) return popSnake(s);
  }
}

function popSnake(s){
  if(!s.alive) return;
  if(s.isPlayer) SFX.die();

  s.alive = false;

  // drop pellets
  const b = s.body;
  for(let i=0;i<b.length;i+=2){
    const pt = b[i];
    WORLD.pellets.push({ x: pt.x, y: pt.y, r: 16 });
  }

  // delayed respawn
  s.respawnT = 1.2 + Math.random() * 1.1;
}

function respawnSnake(s){
  const baseX = player ? player.x : 0;
  const baseY = player ? player.y : 0;

  const a = Math.random()*Math.PI*2;
  const r = SETTINGS.respawnMinR + Math.random()*SETTINGS.respawnRandR;

  s.x = baseX + Math.cos(a)*r;
  s.y = baseY + Math.sin(a)*r;
  s.angle = Math.random()*Math.PI*2;
  s.targetAngle = s.angle;

  s.length = s.respawnLen;
  s.eaten = 0;

  updateRadius(s);
  seedBody(s);

  s.boost=false;
  s.boostDropT=0;
  s.ai.t = 0;
  s.ai.huntT = 0;

  s.alive=true;
}

/* =========================================================
   CAMERA
========================================================= */
let cam = { x:0, y:0, z: 1 };

function updateCamera(dt){
  if(!player) return;

  cam.x += (player.x - cam.x) * (1 - Math.pow(0.001, dt));
  cam.y += (player.y - cam.y) * (1 - Math.pow(0.001, dt));

  const targetZ = clamp(1.08 - (player.length / 22000), 0.72, 1.08);
  cam.z += (targetZ - cam.z) * (1 - Math.pow(0.001, dt));
}

/* =========================================================
   LEADERBOARD
========================================================= */
let leader = null;
let lbTimer = 0;
let _lbLines = [];

function makeLine(rank, s){
  return `${rank}) ${s.name}- ${Math.round(s.length)}`;
}
function updateLeaderboard(dt){
  lbTimer -= dt;
  if(lbTimer > 0) return;
  lbTimer = 0.25;

  const alive = snakes.filter(s=>s.alive).slice();
  alive.sort((a,b)=> b.length - a.length);
  leader = alive[0] || null;

  _lbLines = [];
  for(let i=0;i<5;i++){
    const s = alive[i];
    if(s) _lbLines.push(makeLine(i+1, s));
    else _lbLines.push(`${i+1}) —`);
  }

  if(player && player.alive){
    const idx = alive.indexOf(player);
    const rank = idx >= 0 ? idx + 1 : null;
    if(rank && rank > 5){
      _lbLines.push("");
      _lbLines.push(makeLine(rank, player));
    }
  }
}

/* =========================================================
   DRAW
========================================================= */
const playPanelEl = document.getElementById("playPanel");

function drawPinnedBackground(){
  ctx.fillStyle="white";
  ctx.fillRect(0,0,W,H);

  if(bgImg.complete && bgImg.naturalWidth>0){
    const iw=bgImg.naturalWidth, ih=bgImg.naturalHeight;
    const scale=Math.max(W/iw, H/ih);
    const dw=iw*scale, dh=ih*scale;
    const dx=(W-dw)/2, dy=(H-dh)/2;
    ctx.drawImage(bgImg, dx, dy, dw, dh);
  }

  const g=ctx.createRadialGradient(W*0.5, H*0.42, 60, W*0.5, H*0.5, Math.max(W,H));
  g.addColorStop(0, "rgba(45, 147, 234, 0.07)");
  g.addColorStop(1, "rgba(255,255,255,0)");
  ctx.fillStyle=g;
  ctx.fillRect(0,0,W,H);
}

function getLeaderboardAnchor(fontSize, lineH, linesCount){
  const r = playPanelEl.getBoundingClientRect();
  const margin = 8;
  const x = Math.max(margin, Math.min(W - margin, r.left));
  const neededH = (lineH * (linesCount + 1)) + 4;
  const belowY = r.bottom + 8;

  const musicRect = musicBtn.getBoundingClientRect();
  const maxBottom = Math.min(H - margin, musicRect.top - 10);

  if(belowY + neededH <= maxBottom){
    return { x, y: belowY, maxBottom };
  }
  const yPinned = Math.max(margin, maxBottom - neededH);
  return { x, y: yPinned, maxBottom };
}

function drawLeaderboardLayer(){
  if(!_lbLines || _lbLines.length === 0) return;

  const fontSize = Math.round(clamp(13, W/70, 16));
  const lineH = Math.round(fontSize * 1.25);

  const anchor = getLeaderboardAnchor(fontSize, lineH, _lbLines.length);
  let x = clamp(anchor.x, 8, W - 8);
  let y = anchor.y;

  ctx.save();
  ctx.font = `${fontSize}px "RuneScape UF", Arial, sans-serif`;
  ctx.textAlign = "left";
  ctx.textBaseline = "top";
  ctx.fillStyle = "rgba(0,0,0,0.92)";

  ctx.fillText("leaderboard", x, y);
  y += lineH;

  for(let i=0;i<_lbLines.length;i++){
    const line = _lbLines[i];
    if(!line){ y += Math.round(lineH*0.55); continue; }

    // crown next to #1 line
    if(i === 0 && leader){
      const crown = SPRITES.crown;
      const size = Math.round(lineH * 1.05);
      const textW = ctx.measureText(line).width;
      let cx = x + textW + 8;
      cx = clamp(cx, 8, W - size - 8);
      ctx.save();
      ctx.globalAlpha = 0.95;
      ctx.drawImage(crown, cx, y - 2, size, size);
      ctx.restore();
    }

    ctx.fillText(line, x, y);
    y += lineH;
    if(y > anchor.maxBottom) break;
  }

  ctx.restore();
}

function drawWorld(){
  const z  = cam.z;
  const ox = W*0.5 - cam.x * z;
  const oy = H*0.5 - cam.y * z;

  // pellets
  for(let i=0;i<WORLD.pellets.length;i++){
    const p=WORLD.pellets[i];
    const sx = p.x*z + ox, sy = p.y*z + oy;
    if(sx<-40||sx>W+40||sy<-40||sy>H+40) continue;

    const spr = (p.r<=14) ? SPRITES.pelletSmall : SPRITES.pellet;
    const dw = spr.width*z, dh = spr.height*z;

    ctx.drawImage(spr, sx - dw*0.5, sy - dh*0.5, dw, dh);
  }

  for(const g0 of golden){
  const sx = g0.x*cam.z + ox;
  const sy = g0.y*cam.z + oy;

  if(sx<-80||sx>W+80||sy<-80||sy>H+80) continue;

  const pulse = 0.55 + 0.45*Math.sin(performance.now()*0.006);
  ctx.save();
  ctx.globalAlpha = 0.75 + pulse*0.25;

  const dw = SPRITES.gold.width*cam.z;
  const dh = SPRITES.gold.height*cam.z;
  ctx.drawImage(SPRITES.gold, sx - dw*0.5, sy - dh*0.5, dw, dh);

  ctx.restore();
}


  // snakes
  for(let si=0; si<snakes.length; si++){
    const s=snakes[si];
    if(!s.alive) continue;

    const b=s.body;
    const big = (s.radius > 22);
    const isLeader = (leader && s === leader);

    const size = big ? 58 : 46;
    const spr = getSnakeSprite(size, s.color, isLeader);
    const dw = spr.width*z, dh = spr.height*z;

    for(let i=b.length-1;i>=0;i--){
      const pt=b[i];
      const sx = pt.x*z + ox, sy = pt.y*z + oy;
      if(sx<-90||sx>W+90||sy<-90||sy>H+90) continue;

      ctx.drawImage(spr, sx - dw*0.5, sy - dh*0.5, dw, dh);

      if(i===0){
        ctx.font = `18px "RuneScape UF", Arial, sans-serif`;
        ctx.textAlign="center";
        ctx.textBaseline="bottom";
        ctx.fillStyle = "black";
        ctx.fillText(s.name, sx, sy - dh*0.55);

        if(isLeader){
          const crown = SPRITES.crown;
          const cw = crown.width*z, ch = crown.height*z;
          ctx.drawImage(crown, sx - cw*0.5, sy - dh*0.95 - ch*0.5, cw, ch);

          // tiny glow pulse (already used in your current set)
          const pulse = 0.45 + 0.35 * Math.sin(performance.now() * 0.006);
          ctx.save();
          ctx.globalAlpha = pulse * 0.35;
          ctx.beginPath();
          ctx.arc(sx, sy, spr.width * 0.62, 0, Math.PI * 2);
          ctx.fillStyle = "rgba(255, 215, 0, 1)";
          ctx.fill();
          ctx.restore();
        }
      }
    }
  }
}

function drawLeaderArrow(leaderSnake){
  if(!player || !leaderSnake) return;
  if(leaderSnake === player) return;
  if(!player.alive || !leaderSnake.alive) return;

  // NEW: hide arrow if #1 is on screen
  if(isWorldPointOnScreen(leaderSnake.x, leaderSnake.y, 120)) return;

  const dx = leaderSnake.x - player.x;
  const dy = leaderSnake.y - player.y;
  const dist = Math.hypot(dx,dy);
  if(dist < 80) return;

  const ang = Math.atan2(dy,dx);

  const margin = 26;
  const cx = W/2, cy = H/2;
  const r = Math.min(W,H) * 0.38;

  let ax = cx + Math.cos(ang)*r;
  let ay = cy + Math.sin(ang)*r;
  ax = clamp(ax, margin, W-margin);
  ay = clamp(ay, margin, H-margin);

  ctx.save();
  ctx.translate(ax, ay);
  ctx.rotate(ang);

  ctx.globalAlpha = 0.95;
  ctx.fillStyle = "rgba(45, 147, 234, 0.95)";
  ctx.strokeStyle = "rgba(0,0,0,0.35)";
  ctx.lineWidth = 2;

  ctx.beginPath();
  ctx.moveTo(14, 0);
  ctx.lineTo(-10, -10);
  ctx.lineTo(-6, 0);
  ctx.lineTo(-10, 10);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  ctx.restore();
}

/* =========================================================
   LOOP
========================================================= */
let last = performance.now();
let rafId = null;
let paused = false;
let gameRunning = false;

function updatePauseUI(){
  // pauseBtn always says "pause game"
  pauseOverlay.style.display = paused ? "flex" : "none";
  pauseOverlay.setAttribute("aria-hidden", paused ? "false" : "true");
}

function stopLoop(){
  if(rafId !== null){
    cancelAnimationFrame(rafId);
    rafId = null;
  }
}

function startLoop(){
  stopLoop();                 // prevents stacked loops
  last = performance.now();    // reset timing so dt doesn't jump
  rafId = requestAnimationFrame(tick);
}

function setPaused(on){
  paused = !!on;

  // If game isn't running yet (still on name screen before first start),
  // just update UI and don't start/stop loops.
  if(!gameRunning){
    updatePauseUI();
    return;
  }

  if(paused){
    boostHeld = false;   // stop boost immediately
    stopLoop();          // hard freeze
  }else{
    startLoop();         // resume cleanly
  }

  updatePauseUI();
}

function tick(now){
  if(paused || !gameRunning){
    rafId = null;
    return; // DO NOT schedule another frame
  }
  const dt = Math.min(0.033, (now - last)/1000);
  last = now;
  huntersNow = 0;

  if(player && player.alive){
  if(IS_MOBILE){
    // joystick vector steers relative to screen center
    const dx = joyVec.x;
    const dy = joyVec.y;

    // if stick is near center, don't force direction changes
    const m2 = dx*dx + dy*dy;
    if(m2 > 0.0004){
      player.targetAngle = Math.atan2(dy, dx);
    }
  }else{
    const dx = pointer.x - W/2;
    const dy = pointer.y - H/2;
    player.targetAngle = Math.atan2(dy, dx);
  }
}


  // AI
  for(let i=0;i<snakes.length;i++){
    const s=snakes[i];
    if(!s.alive) continue;
    if(!s.isPlayer) aiUpdate(s, dt);
  }

  // movement
  for(let i=0;i<snakes.length;i++){
    const s=snakes[i];
    if(!s.alive) continue;
    updateMovement(s, dt);
    addBodyPointIfNeeded(s);
    trimBodyToLength(s);
  }

  // delayed respawns
  for(let i=0;i<snakes.length;i++){
    const s = snakes[i];
    if(s.alive) continue;
    if(s.respawnT > 0){
      s.respawnT -= dt;
      if(s.respawnT <= 0) respawnSnake(s);
    }
  }

  updateCamera(dt);

  ensurePellets(cam.x, cam.y);
  rebuildPelletGrid();
  rebuildBodyGrid();

  // eating
  for(let i=0;i<snakes.length;i++){
    const s=snakes[i];
    if(!s.alive) continue;
    eatCheck(s);
  }
  compactPellets();

  // collisions
  for(let i=0;i<snakes.length;i++){
    const s=snakes[i];
    if(!s.alive) continue;
    checkPop(s);
  }

  updateLeaderboard(dt);

  // draw order
  drawPinnedBackground();
  drawLeaderboardLayer();
  drawWorld();
  drawLeaderArrow(leader);

  if(player){
    const b = player.boost ? "on" : "off";
    statsEl.textContent = `length: ${Math.round(player.length)} • eaten: ${player.eaten.toLocaleString()} • boost: ${b}`;
  }

  requestAnimationFrame(tick);
}

/* =========================================================
   START / RESET
========================================================= */

function startGame(){
  unlockAudio();
  tryStartMusic();

  WORLD.seed = (WORLD.seed + ((Math.random()*1e9)|0)) >>> 0;

  snakes.length = 0;
  WORLD.pellets.length = 0;
  golden = [];
  leader = null;
  _lbLines = [];

  const nm = (nameInput.value || "frog").toLowerCase().trim().slice(0,18) || "frog";
  spawnPlayer(nm);
  spawnWorldSnakes();

  cam.x = player.x;
  cam.y = player.y;
  cam.z = 1;

  nameOverlay.style.display = "none";
  nameOverlay.setAttribute("aria-hidden","true");

  gameRunning = true;
  paused = false;
  updatePauseUI();
  startLoop();
}

startBtn.addEventListener("click", startGame);
nameInput.addEventListener("keydown", (e)=>{ if(e.key === "Enter") startGame(); });
pauseBtn.addEventListener("click", ()=>{
  setPaused(true);
});

resetBtn.addEventListener("click", ()=>{
  setPaused(true);
  nameOverlay.style.display = "flex";
  nameOverlay.setAttribute("aria-hidden","false");
  try{ nameInput.focus(); }catch{}
});

requestAnimationFrame(()=>{ try{ nameInput.focus(); }catch{} });
</script>
</body>
</html>
